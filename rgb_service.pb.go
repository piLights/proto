// Code generated by protoc-gen-go.
// source: rgb_service.proto
// DO NOT EDIT!

package LighterGRPC

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LogLevel int32

const (
	LogLevel_DEBUG LogLevel = 0
	LogLevel_INFO  LogLevel = 1
	LogLevel_WARN  LogLevel = 2
	LogLevel_ERROR LogLevel = 3
	LogLevel_PANIC LogLevel = 4
)

var LogLevel_name = map[int32]string{
	0: "DEBUG",
	1: "INFO",
	2: "WARN",
	3: "ERROR",
	4: "PANIC",
}
var LogLevel_value = map[string]int32{
	"DEBUG": 0,
	"INFO":  1,
	"WARN":  2,
	"ERROR": 3,
	"PANIC": 4,
}

func (x LogLevel) String() string {
	return proto.EnumName(LogLevel_name, int32(x))
}
func (LogLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type ColorMessage struct {
	Onstate bool  `protobuf:"varint,1,opt,name=onstate" json:"onstate,omitempty"`
	R       int32 `protobuf:"varint,2,opt,name=r" json:"r,omitempty"`
	G       int32 `protobuf:"varint,3,opt,name=g" json:"g,omitempty"`
	B       int32 `protobuf:"varint,4,opt,name=b" json:"b,omitempty"`
	Opacity int32 `protobuf:"varint,5,opt,name=opacity" json:"opacity,omitempty"`
}

func (m *ColorMessage) Reset()                    { *m = ColorMessage{} }
func (m *ColorMessage) String() string            { return proto.CompactTextString(m) }
func (*ColorMessage) ProtoMessage()               {}
func (*ColorMessage) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *ColorMessage) GetOnstate() bool {
	if m != nil {
		return m.Onstate
	}
	return false
}

func (m *ColorMessage) GetR() int32 {
	if m != nil {
		return m.R
	}
	return 0
}

func (m *ColorMessage) GetG() int32 {
	if m != nil {
		return m.G
	}
	return 0
}

func (m *ColorMessage) GetB() int32 {
	if m != nil {
		return m.B
	}
	return 0
}

func (m *ColorMessage) GetOpacity() int32 {
	if m != nil {
		return m.Opacity
	}
	return 0
}

type StateMessage struct {
	Onstate bool `protobuf:"varint,1,opt,name=onstate" json:"onstate,omitempty"`
}

func (m *StateMessage) Reset()                    { *m = StateMessage{} }
func (m *StateMessage) String() string            { return proto.CompactTextString(m) }
func (*StateMessage) ProtoMessage()               {}
func (*StateMessage) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *StateMessage) GetOnstate() bool {
	if m != nil {
		return m.Onstate
	}
	return false
}

type ScheduledSwitch struct {
	Time    int64 `protobuf:"varint,1,opt,name=time" json:"time,omitempty"`
	Onstate bool  `protobuf:"varint,2,opt,name=onstate" json:"onstate,omitempty"`
}

func (m *ScheduledSwitch) Reset()                    { *m = ScheduledSwitch{} }
func (m *ScheduledSwitch) String() string            { return proto.CompactTextString(m) }
func (*ScheduledSwitch) ProtoMessage()               {}
func (*ScheduledSwitch) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *ScheduledSwitch) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ScheduledSwitch) GetOnstate() bool {
	if m != nil {
		return m.Onstate
	}
	return false
}

type LogEntry struct {
	Time    int64  `protobuf:"varint,1,opt,name=time" json:"time,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *LogEntry) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *LogEntry) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type LogRequest struct {
	LogLevel LogLevel `protobuf:"varint,1,opt,name=logLevel,enum=LighterGRPC.LogLevel" json:"logLevel,omitempty"`
	Amount   int32    `protobuf:"varint,2,opt,name=amount" json:"amount,omitempty"`
}

func (m *LogRequest) Reset()                    { *m = LogRequest{} }
func (m *LogRequest) String() string            { return proto.CompactTextString(m) }
func (*LogRequest) ProtoMessage()               {}
func (*LogRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *LogRequest) GetLogLevel() LogLevel {
	if m != nil {
		return m.LogLevel
	}
	return LogLevel_DEBUG
}

func (m *LogRequest) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func init() {
	proto.RegisterType((*ColorMessage)(nil), "LighterGRPC.ColorMessage")
	proto.RegisterType((*StateMessage)(nil), "LighterGRPC.StateMessage")
	proto.RegisterType((*ScheduledSwitch)(nil), "LighterGRPC.ScheduledSwitch")
	proto.RegisterType((*LogEntry)(nil), "LighterGRPC.LogEntry")
	proto.RegisterType((*LogRequest)(nil), "LighterGRPC.LogRequest")
	proto.RegisterEnum("LighterGRPC.LogLevel", LogLevel_name, LogLevel_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RgbService service

type RgbServiceClient interface {
	GetStatus(ctx context.Context, in *Request, opts ...grpc.CallOption) (*ColorMessage, error)
	OpenStream(ctx context.Context, in *Request, opts ...grpc.CallOption) (RgbService_OpenStreamClient, error)
	LoadServerLog(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (RgbService_LoadServerLogClient, error)
	ScheduleSwitchState(ctx context.Context, in *ScheduledSwitch, opts ...grpc.CallOption) (*Confirmation, error)
	SetColor(ctx context.Context, in *ColorMessage, opts ...grpc.CallOption) (*Confirmation, error)
	SwitchState(ctx context.Context, in *StateMessage, opts ...grpc.CallOption) (*Confirmation, error)
}

type rgbServiceClient struct {
	cc *grpc.ClientConn
}

func NewRgbServiceClient(cc *grpc.ClientConn) RgbServiceClient {
	return &rgbServiceClient{cc}
}

func (c *rgbServiceClient) GetStatus(ctx context.Context, in *Request, opts ...grpc.CallOption) (*ColorMessage, error) {
	out := new(ColorMessage)
	err := grpc.Invoke(ctx, "/LighterGRPC.RgbService/GetStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rgbServiceClient) OpenStream(ctx context.Context, in *Request, opts ...grpc.CallOption) (RgbService_OpenStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RgbService_serviceDesc.Streams[0], c.cc, "/LighterGRPC.RgbService/OpenStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &rgbServiceOpenStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RgbService_OpenStreamClient interface {
	Recv() (*ColorMessage, error)
	grpc.ClientStream
}

type rgbServiceOpenStreamClient struct {
	grpc.ClientStream
}

func (x *rgbServiceOpenStreamClient) Recv() (*ColorMessage, error) {
	m := new(ColorMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rgbServiceClient) LoadServerLog(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (RgbService_LoadServerLogClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_RgbService_serviceDesc.Streams[1], c.cc, "/LighterGRPC.RgbService/LoadServerLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &rgbServiceLoadServerLogClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RgbService_LoadServerLogClient interface {
	Recv() (*LogEntry, error)
	grpc.ClientStream
}

type rgbServiceLoadServerLogClient struct {
	grpc.ClientStream
}

func (x *rgbServiceLoadServerLogClient) Recv() (*LogEntry, error) {
	m := new(LogEntry)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rgbServiceClient) ScheduleSwitchState(ctx context.Context, in *ScheduledSwitch, opts ...grpc.CallOption) (*Confirmation, error) {
	out := new(Confirmation)
	err := grpc.Invoke(ctx, "/LighterGRPC.RgbService/ScheduleSwitchState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rgbServiceClient) SetColor(ctx context.Context, in *ColorMessage, opts ...grpc.CallOption) (*Confirmation, error) {
	out := new(Confirmation)
	err := grpc.Invoke(ctx, "/LighterGRPC.RgbService/SetColor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rgbServiceClient) SwitchState(ctx context.Context, in *StateMessage, opts ...grpc.CallOption) (*Confirmation, error) {
	out := new(Confirmation)
	err := grpc.Invoke(ctx, "/LighterGRPC.RgbService/SwitchState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RgbService service

type RgbServiceServer interface {
	GetStatus(context.Context, *Request) (*ColorMessage, error)
	OpenStream(*Request, RgbService_OpenStreamServer) error
	LoadServerLog(*LogRequest, RgbService_LoadServerLogServer) error
	ScheduleSwitchState(context.Context, *ScheduledSwitch) (*Confirmation, error)
	SetColor(context.Context, *ColorMessage) (*Confirmation, error)
	SwitchState(context.Context, *StateMessage) (*Confirmation, error)
}

func RegisterRgbServiceServer(s *grpc.Server, srv RgbServiceServer) {
	s.RegisterService(&_RgbService_serviceDesc, srv)
}

func _RgbService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RgbServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LighterGRPC.RgbService/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RgbServiceServer).GetStatus(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _RgbService_OpenStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Request)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RgbServiceServer).OpenStream(m, &rgbServiceOpenStreamServer{stream})
}

type RgbService_OpenStreamServer interface {
	Send(*ColorMessage) error
	grpc.ServerStream
}

type rgbServiceOpenStreamServer struct {
	grpc.ServerStream
}

func (x *rgbServiceOpenStreamServer) Send(m *ColorMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _RgbService_LoadServerLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RgbServiceServer).LoadServerLog(m, &rgbServiceLoadServerLogServer{stream})
}

type RgbService_LoadServerLogServer interface {
	Send(*LogEntry) error
	grpc.ServerStream
}

type rgbServiceLoadServerLogServer struct {
	grpc.ServerStream
}

func (x *rgbServiceLoadServerLogServer) Send(m *LogEntry) error {
	return x.ServerStream.SendMsg(m)
}

func _RgbService_ScheduleSwitchState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduledSwitch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RgbServiceServer).ScheduleSwitchState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LighterGRPC.RgbService/ScheduleSwitchState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RgbServiceServer).ScheduleSwitchState(ctx, req.(*ScheduledSwitch))
	}
	return interceptor(ctx, in, info, handler)
}

func _RgbService_SetColor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ColorMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RgbServiceServer).SetColor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LighterGRPC.RgbService/SetColor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RgbServiceServer).SetColor(ctx, req.(*ColorMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _RgbService_SwitchState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RgbServiceServer).SwitchState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/LighterGRPC.RgbService/SwitchState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RgbServiceServer).SwitchState(ctx, req.(*StateMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _RgbService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "LighterGRPC.RgbService",
	HandlerType: (*RgbServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStatus",
			Handler:    _RgbService_GetStatus_Handler,
		},
		{
			MethodName: "ScheduleSwitchState",
			Handler:    _RgbService_ScheduleSwitchState_Handler,
		},
		{
			MethodName: "SetColor",
			Handler:    _RgbService_SetColor_Handler,
		},
		{
			MethodName: "SwitchState",
			Handler:    _RgbService_SwitchState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenStream",
			Handler:       _RgbService_OpenStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LoadServerLog",
			Handler:       _RgbService_LoadServerLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rgb_service.proto",
}

func init() { proto.RegisterFile("rgb_service.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 455 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x53, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xcd, 0xe6, 0xa3, 0x38, 0xd3, 0x14, 0xdc, 0x85, 0x82, 0xa9, 0x38, 0x54, 0x3e, 0x45, 0x1c,
	0xa2, 0x52, 0x2e, 0x9c, 0x88, 0x9a, 0x10, 0xa2, 0x4a, 0x26, 0x89, 0xd6, 0x42, 0x3d, 0x22, 0x3b,
	0x19, 0x36, 0x96, 0x6c, 0x6f, 0x58, 0x6f, 0x8a, 0xfa, 0xab, 0xf8, 0x8b, 0x68, 0x77, 0x6d, 0x64,
	0xb7, 0x6a, 0x51, 0x6f, 0xf3, 0x76, 0x66, 0x9e, 0x9f, 0xde, 0x1b, 0xc3, 0xb1, 0xe4, 0xf1, 0x8f,
	0x02, 0xe5, 0x4d, 0xb2, 0xc6, 0xd1, 0x4e, 0x0a, 0x25, 0xe8, 0x61, 0x90, 0xf0, 0xad, 0x42, 0x39,
	0x67, 0xab, 0xe9, 0xe9, 0x11, 0xc7, 0x1c, 0x65, 0x94, 0xda, 0x9e, 0x9f, 0xc2, 0x60, 0x2a, 0x52,
	0x21, 0xbf, 0x61, 0x51, 0x44, 0x1c, 0xa9, 0x07, 0xcf, 0x44, 0x5e, 0xa8, 0x48, 0xa1, 0x47, 0xce,
	0xc8, 0xd0, 0x61, 0x15, 0xa4, 0x03, 0x20, 0xd2, 0x6b, 0x9f, 0x91, 0x61, 0x8f, 0x11, 0xa9, 0x11,
	0xf7, 0x3a, 0x16, 0x71, 0x8d, 0x62, 0xaf, 0x6b, 0x51, 0x6c, 0x38, 0x76, 0xd1, 0x3a, 0x51, 0xb7,
	0x5e, 0xcf, 0xbc, 0x55, 0xd0, 0x1f, 0xc2, 0x20, 0xd4, 0x64, 0xff, 0xfd, 0x9a, 0x3f, 0x86, 0x17,
	0xe1, 0x7a, 0x8b, 0x9b, 0x7d, 0x8a, 0x9b, 0xf0, 0x77, 0xa2, 0xd6, 0x5b, 0x4a, 0xa1, 0xab, 0x92,
	0xcc, 0x4e, 0x76, 0x98, 0xa9, 0xeb, 0x04, 0xed, 0x26, 0xc1, 0x27, 0x70, 0x02, 0xc1, 0x67, 0xb9,
	0x92, 0xb7, 0x0f, 0x6d, 0x66, 0x56, 0x85, 0xd9, 0xec, 0xb3, 0x0a, 0xfa, 0xd7, 0x00, 0x81, 0xe0,
	0x0c, 0x7f, 0xed, 0xb1, 0x50, 0xf4, 0x03, 0x38, 0xa9, 0xe0, 0x01, 0xde, 0x60, 0x6a, 0xf6, 0x9f,
	0x5f, 0x9c, 0x8c, 0x6a, 0x7e, 0x8e, 0x82, 0xb2, 0xc9, 0xfe, 0x8d, 0xd1, 0xd7, 0x70, 0x10, 0x65,
	0x62, 0x9f, 0xab, 0xd2, 0xae, 0x12, 0xbd, 0x1f, 0x1b, 0x49, 0x76, 0xa6, 0x0f, 0xbd, 0x2f, 0xb3,
	0xc9, 0xf7, 0xb9, 0xdb, 0xa2, 0x0e, 0x74, 0xaf, 0x16, 0x5f, 0x97, 0x2e, 0xd1, 0xd5, 0xf5, 0x25,
	0x5b, 0xb8, 0x6d, 0xdd, 0x9e, 0x31, 0xb6, 0x64, 0x6e, 0x47, 0x97, 0xab, 0xcb, 0xc5, 0xd5, 0xd4,
	0xed, 0x5e, 0xfc, 0xe9, 0x00, 0x30, 0x1e, 0x87, 0x36, 0x5d, 0xfa, 0x19, 0xfa, 0x73, 0x54, 0xda,
	0xd0, 0x7d, 0x41, 0x5f, 0x35, 0x54, 0x95, 0xea, 0x4f, 0xdf, 0x36, 0x5e, 0xeb, 0x49, 0xfb, 0x2d,
	0x3a, 0x06, 0x58, 0xee, 0x30, 0x0f, 0x95, 0xc4, 0x28, 0x7b, 0x32, 0xc1, 0x39, 0xa1, 0x53, 0x38,
	0x0a, 0x44, 0xb4, 0xd1, 0x7a, 0x50, 0x06, 0x82, 0xd3, 0x37, 0x77, 0xad, 0xa9, 0x68, 0xee, 0x79,
	0x66, 0x82, 0xf1, 0x5b, 0xe7, 0x84, 0xae, 0xe0, 0x65, 0x95, 0xb4, 0x0d, 0xda, 0x5c, 0x08, 0x7d,
	0xd7, 0xd8, 0xb8, 0x73, 0x0b, 0xf7, 0x64, 0xe5, 0x3f, 0x13, 0x99, 0x45, 0x2a, 0x11, 0xb9, 0xdf,
	0xa2, 0x13, 0x70, 0x42, 0x54, 0x46, 0x2b, 0x7d, 0x58, 0xff, 0xe3, 0x1c, 0x33, 0x38, 0xac, 0xab,
	0x69, 0xce, 0xd6, 0x6f, 0xf8, 0x51, 0x9a, 0xc9, 0x09, 0x1c, 0x6f, 0x70, 0xb4, 0x4b, 0x52, 0x3d,
	0x52, 0xd8, 0x7f, 0x6e, 0x45, 0xe2, 0x03, 0x53, 0x7c, 0xfc, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x9a,
	0x4b, 0x40, 0x56, 0xad, 0x03, 0x00, 0x00,
}
